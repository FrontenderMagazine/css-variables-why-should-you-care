# Переменные CSS: на кой оно надо

CSS-переменные, точнее известные как кастомные CSS-свойства, появляются в
Chrome 49. Они могут использоваться для уменьшения повторяющегося кода в CSS, а
также для тяжёлых эффектов наподобие смены тем на лету и, потенциально,
расширения и полифилирования будущих особенностей CSS.

## Мусор в CSS

Обычная практика при разработке приложения - отложить набор хороших цветов,
которые будут снова использоваться впоследствии, чтобы не нарушать стилистику
приложения. Увы, многократное упоминание значений этих цветов в CSS-коде - не
просто рутина, но ещё и предрасположенность к ошибкам. Если в какой-то момент
один из цветов нужно поменять, разработчик может неосторожно воспользоваться
"find-and-replace" по всему документу, что в достаточно большом проекте вполне
может быть опасно.

В последнее время многие разработчики стали использовать CSS-препроцессоры типа
SASS или LESS, которые справляются с этой проблемой при помощи переменных
препроцессора. Хотя эти инструменты заметно улучшили продуктивность разработки,
используемые ими переменные имеют очень серьёзный недостаток: они статичны и не
могут меняться на лету. Добавление возможности менять переменные в рантайме не
только позволяет такие вещи, как динамическая смена тем, но и влечёт серьёзные
улучшения отзывчивого дизайна и возможность полифилировани будущих особенностей
CSS. С выходом Chrome 49, эти возможности стали доступны в виде кастомных
CSS-свойств.

## Кастомные свойства в двух словах

Кастомные свойства добавляют две новые особенности в наш инструментарий CSS:

Автор может присваивать произвольные значения свойствам с придуманными им самим
именами. Функция `var()` позволяет автору использовать эти значения в других
свойствах.

Краткий пример для демонстрации:

    :root {
      --main-color: #06c;
    }

    #foo h1 {
      color: var(--main-color);
    }

`--main-color` - это определённое автором кастомное свойство со значением #06c.
Заметьте, что все кастомные свойства начинаются с двух дефисов.

Функция `var()` возвращает значение кастомного свойства и заменяется на него, в
результате чего получается `color: #06c;`. Если кастомное свойство определено
где-то в Вашей таблице стилей, оно должно быть доступно функции `var`. 

Синтаксис на первый взгляд может показаться странным. Многие разработчики
спрашивают: "Почему бы просто не использовать `$foo`" для имён переменных?"
Такой подход был выбран специально для того, чтобы особенность была максимально
гибкой, и в перспективе могла позволить `$foo`-макросы. Более подробно можно
почитать [сообщение][1] одного из авторов, Таба Аткинса.

## Синтаксис кастомных свойств

Синтаксис кастомных свойств довольно непосредственен.

    --header-color: #06c;

Отметим, что кастомные свойства регистрозависимы, то есть `--header-color` и
`--Header-Color` - это разные кастомные свойства. Хотя разрешённый синтаксис
кастомных свойств поначалу может казаться простым, на самом деле он весьма
снисходителен. К примеру, ниже - пример валидного кастомного свойства:

    --foo: if(x > 5) this.width = 10;

Хотя это выражение не будет работать как переменная (а также не будет валидным
для любого обычного свойства), в принципе JavaScript может прочитать и
распознать его в рантайме. Это означает, что кастомные свойства могут открыть
доступ ко всевозможным интересностям, недоступным с нынешними
CSS-препроцессорами. Так что если Вы думаете что-то вроде "*зевая* Какая
разница, у меня есть SASS…", подумайте ещё раз! Это не те переменные, с которыми
Вы привыкли работать.

### Каскад

Кастомные свойства следуют стандартным правилам каскада, так что Вы можете
определить одно и то же свойство на разных уровнях специфичности.

    :root { --color: blue; }
    div { --color: green; }
    #alert { --color: red; }
    * { color: var(--color); }

    <p>I inherited blue from the root element!</p>
    <div>I got green set directly on me!</div>
    <div id="alert">
      While I got red set directly on me!
      <p>I’m red too, because of inheritance!</p>
    </div>

Это означает, что можно использовать кастомные свойства в медиавыражениях для
помощи с отзвычивым дизайном. Примером использования может быть расширение
внешних отступов от основных структурных элементов при увеличении размеров
экрана:

    :root {
      --gutter: 4px;
    }

    section {
      margin: var(--gutter);
    }

    @media (min-width: 600px) {
      :root {
        --gutter: 16px;
      }
    }

Необходимо отметить, что вышеприведённый фрагмент кода невыполним на нынешних
CSS-препроцессорах, неспособных определять переменные внутри медиавыражений.
У этой возможности огромный потенциал!

Также допустимо иметь кастомные свойства, получающие своё значение из других
кастомных свойств. Это может быть крайне полезно для настройки тем:

    :root {
      --primary-color: red;
      --logo-text: var(--primary-color);
    }

## Функция var()

Чтобы получить и использовать значение кастомного свойства, понадобится функция
`var()`. Её синтаксис выглядит так:

    var(<custom-property-name> [, <declaration-value> ]? )

Здесь `<custom-property-name>` - имя определённого автором кастомного
свойства, `<declaration-value>` - фолбек, который будет использован, если
упомянутое кастомное свойство не является валидным. Фолбек может быть списком,
разделённым запятыми; он будет преобразован к единому значению. Например,
`var(--font-stack, "Roboto", "Helvetica");` определяет фолбек
`"Roboto", "Helvetica"`. Имейте в виду, что краткая запись (как в случае
внешних и внутренних отступов) разделяется не запятыми, так что приемлемый
фолбек для внутренних отступов будет выглядеть примерно так.

    p {
      padding: var(--pad, 10px 15px 20px);
    }

С такими фолбеками автор компоненты может написать для своего элемента
пуленепробиваемые стили:

    /* В стиле компоненты: */
    .component .header {
      color: var(--header-color, blue);
    }
    .component .text {
      color: var(--text-color, black);
    }

    /* В стиле основного приложения: */
    .component {
      --text-color: #080;
        /* header-color не установлен,
           поэтому остаётся синим
           в соответствии с фолбеком */
    }

Этот метод особенно полезен для стилизации веб-компонент, использующих
Shadow DOM, поскольку кастомные свойства могут пересекать теневые границы.
Автор веб-компоненты может создать начальный дизайн при помощи фолбеков, а
потом настроить стили при помощи кастомных свойств.

    <!-- В определении веб-компоненты: -->
    <x-foo>
      #shadow
        <style>
          p {
            background-color: var(--text-background, blue);
          }
        </style>
        <p>
          This text has a yellow background because the document styled me!
          Otherwise it would be blue.
        </p>
    </x-foo>

    /* В стиле основного приложения: */
    x-foo {
      --text-background: yellow;
    }

При использовании `var()` нужно следить за несколькими подвохами. Переменные не
могут быть именами свойств. К примеру:

    .foo {
      --side: margin-top;
      var(--side): 20px;
    }

Это не является эквивалентом присваивания `margin-top: 20px;`. Более того,
второе объявление не является валидным, и выбросит ошибку.

Аналогично, невозможно создать значение, часть котороо берётся из переменной:

    .foo {
      --gap: 20;
      margin-top: var(--gap)px;
    }

Это тоже не является эквивалентом присваивания `margin-top: 20px;`. Чтобы
собрать значение, понадобится кое-что другое: функция `calc()`.

## Создание значений с помощью calc()

На случай, если вы никогда раньше с ней не работали, функция `calc()` -
небольшой удобный инструмент, позволяющий проводить вычисления для определения
значений CSS. Она [поддерживается всеми современными браузерами][2], и может
быть использована вместе с кастомными свойствами для создания новых значений.
Например:

    .foo {
      --gap: 20;
      margin-top: calc(var(--gap) * 1px); /* зашибись */
    }

## Работа с кастомными свойствами в JavaScript

Чтобы получить значение кастомного свойства в рантайме, используйте метод
`getPropertyValue()` вычисленного объекта CSSStyleDeclaration.

    /* CSS */
    :root {
      --primary-color: red;
    }

    p {
      color: var(--primary-color);
    }

    <!-- HTML -->
    <p>I’m a red paragraph!</p>

    /* JS */
    var styles = getComputedStyle(document.documentElement);
    var value = String(styles.getPropertyValue('--primary-color')).trim();
    // value = 'red'

Аналогично, чтобы в рантайме менять значение кастомного свойства, используйте
метод `setProperty()` объекта `CSSStyleDeclaration`.

    /* CSS */
    :root {
      --primary-color: red;
    }

    p {
      color: var(--primary-color);
    }

    <!-- HTML -->
    <p>Now I’m a green paragraph!</p>

    /* JS */
    document.documentElement.style.setProperty('--primary-color', 'green');

Также при задании значения кастомного свойства в рантайме можно использовать
ссылку на другое кастомное свойство, вставив функцию `var()` в вызов
`setProperty()`.

    /* CSS */
    :root {
      --primary-color: red;
      --secondary-color: blue;
    }

    <!-- HTML -->
    <p>Sweet! I’m a blue paragraph!</p>

    /* JS */
    document.documentElement.style.setProperty('--primary-color', 'var(--secondary-color)');

Можете представить, к каким разнообразным рантайм-эффектам это может привести.

## Поддерживыемые браузеры

На данный момент Chrome 49, Firefox 42, Safari 9.1, и iOS Safari 9.3
поддерживают кастомные свойства.

## Демо
                                                                                 
Взгляните на [пример][3], чтобы получить представление о всевозможных
интересностям, доступным благодаря кастомным свойствам.

## Где почитать

Если Вы хотите узнать больше про кастомные свойства, Филип Уолтон из команды
Google Analytics написал учебник для начинающих про то, [почему он в восторге от
кастомных свойств][4], и за их продвижением можно следить в других браузерах на
[chromestatus.com][5].

Если не указано обратного, всё содержимое этой страницы находится под лицензией
[Creative Commons Attribution 3.0 License][6], а фрагменты кода находятся под
лицензией [Apache 2.0 License][7]. Подробнее смотри [Terms of Service][8].

 [1]: http://www.xanthir.com/blog/b4KT0
 [2]: http://caniuse.com/#search=calc
 [3]: https://googlechrome.github.io/samples/css-custom-properties/index.html

 [4]: http://philipwalton.com/articles/why-im-excited-about-native-css-variables/
 [5]: https://www.chromestatus.com/features/6401356696911872
 [6]: http://creativecommons.org/licenses/by/3.0/
 [7]: http://www.apache.org/licenses/LICENSE-2.0
 [8]: https://developers.google.com/site-terms
